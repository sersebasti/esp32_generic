<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ESP32 FS Toolbox</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Arial, sans-serif; }
    body { margin: 20px; }
    h1 { font-size: 22px; margin: 0 0 14px; }
    h2 { font-size: 16px; margin: 18px 0 8px; }
    .row { display: flex; gap: 8px; align-items: center; margin: 8px 0; flex-wrap: wrap; }
    input[type="text"], select { padding: 8px; min-width: 220px; }
    input[type="file"] { padding: 6px; }
    button { padding: 8px 12px; border-radius: 10px; border: 1px solid #ccc; cursor: pointer; }
    button.danger { background:#ffe9e9; border-color:#f2b5b5 }
    .muted { color: #666; font-size: 12px; }
    pre { background: #f7f7f7; padding: 12px; border-radius: 8px; max-height: 50vh; overflow: auto; white-space: pre-wrap; }
    code { background:#f0f0f0; padding:2px 6px; border-radius:6px; }
    .card { border:1px solid #eee; border-radius:12px; padding:12px; margin:12px 0; }
    .cols { display:grid; grid-template-columns: 1fr; gap: 14px; }
    .blocked { opacity: 0.5; filter: grayscale(100%); pointer-events: none; user-select: none; }
    .banner { padding: 10px 12px; border-radius: 10px; margin: 8px 0; }
    .banner.warn { background: #fff2e6; border: 1px solid #ffd2a8; color: #7a3d00; }
    .hidden { display: none; }
    @media (min-width: 900px) {
      .cols { grid-template-columns: 1fr 1fr; }
    }
  </style>
</head>
<body>
  <h1>ESP32 FS Toolbox</h1>

  <!-- Barra IP + utilità -->
  <div class="card">
    <div class="row">
      <label for="ip">IP ESP32:</label>
      <input id="ip" type="text" value="192.168.1.10" placeholder="es. 192.168.1.10" />
      <button id="statusBtn">Status</button>
      <button id="rebootBtn">Reboot</button>
    </div>
    <div class="row"><span class="muted">URL:</span> <code id="url"></code></div>
    <div class="row"><span id="status" class="muted">Pronto.</span></div>
    <div id="connBanner" class="banner warn hidden">Dispositivo non raggiungibile all'IP indicato. Inserisci l'IP corretto e premi "Status".</div>
  </div>

  <div class="cols">
    <!-- Sezione Viewer/Download/Delete -->
    <div id="viewerCard" class="card">
      <h2>File viewer</h2>

      <div class="row">
        <span class="muted">Cartella:</span> <code id="cwd">/</code>
      </div>

      <div class="row">
        <label>Selezione cartelle</label>
        <div id="folderButtons" class="row"></div>
      </div>

      <div class="row">
        <button id="refreshBtn">Aggiorna lista file</button>
        <span class="muted">Ammessi in lista: .txt, .py, .json, .html</span>
      </div>

      <div class="row">
        <label for="fname">File:</label>
        <select id="fname"></select>
      </div>

      <div class="row">
        <button id="viewBtn">Visualizza</button>
        <button id="downloadBtn">Scarica</button>
        <button id="deleteBtn" class="danger">Elimina</button>
      </div>

      <h2>Anteprima</h2>
      <pre id="preview">(contenuto)</pre>
    </div>

    <!-- Sezione Upload -->
    <div id="uploadCard" class="card">
      <h2>Upload file</h2>
      <div class="row">
        <input id="fileInput" type="file" />
        <button id="uploadBtn">Upload</button>
      </div>
    </div>

    <!-- Sezione Upload -->
    <div class="card">
      <h2>Risultato</h2>
      <pre id="result">(nessuna azione ancora)</pre>
    </div>
  </div>
  
  



  <script>
    // ---- Helpers comuni ----
    const $ = (sel) => document.querySelector(sel);
    const ipEl = $('#ip');
    const urlEl = $('#url');
    const statusEl = $('#status');
    const connBanner = $('#connBanner');
    const viewerCard = $('#viewerCard');
    const uploadCard = $('#uploadCard');

    // Viewer refs
    const fnameEl = $('#fname');
    const previewEl = $('#preview');

    // Uploader refs
    const fileEl = $('#fileInput');
    const resultEl = $('#result');

    function base() {
      const ip = ipEl.value.trim();
      if (!ip) throw new Error('IP non valido');
      return `http://${ip}`;
    }

    function setURL(u) { urlEl.textContent = u || ''; }

    function normalize(path){ return (path || '').replace(/\\/g,'/'); }
    function sanitizeName(path) {
      return normalize(path).replace(/^\/+/, '');
    }
    function joinPath(dir, name){
      dir = normalize(dir);
      name = normalize(name);
      if(!dir || dir==='/' ) return '/' + sanitizeName(name);
      return (dir.replace(/\/$/, '')) + '/' + sanitizeName(name);
    }

    function allowed(path) {
      const name = sanitizeName(path);
      // Mostra solo alcuni tipi nel viewer, ma l'upload può inviare qualunque file
      return /\.(txt|py|json|html)$/i.test(name);
    }

    async function fetchText(url, opts={}) {
      setURL(url);
      const r = await fetch(url, opts);
      const txt = await r.text();
      if (!r.ok) throw new Error("HTTP " + r.status + " " + txt);
      return txt;
    }

    // ---- Connessione / Blocco UI ----
    let isLocked = false;
    function setLocked(lock){
      isLocked = !!lock;
      if (isLocked) {
        viewerCard.classList.add('blocked');
        uploadCard.classList.add('blocked');
        connBanner.classList.remove('hidden');
      } else {
        viewerCard.classList.remove('blocked');
        uploadCard.classList.remove('blocked');
        connBanner.classList.add('hidden');
      }
    }

    function withTimeout(promise, ms){
      const ctrl = new AbortController();
      const t = setTimeout(()=> ctrl.abort(), ms);
      return (async ()=>{
        try{
          return await promise(ctrl.signal);
        } finally {
          clearTimeout(t);
        }
      })();
    }

    async function tryStatus(signal){
      const resp = await fetch(`${base()}/status`, { signal, cache: 'no-store' });
      const text = await resp.text();
      let parsed = null;
      try { parsed = JSON.parse(text); } catch(_) {}
      return { ok: resp.ok, text, json: parsed };
    }

    function statusLooksOK(s){
      if (!s) return false;
      // Caso richiesto: se il testo è '9', consideralo OK
      if (typeof s.text === 'string' && s.text.trim() === '9') return true;
      // In questo progetto /status restituisce JSON con campi noti: ip/uptime/version
      if (s.ok && s.json && (s.json.ip || s.json.version || s.json.uptime_s != null)) return true;
      return false;
    }

    async function checkDevice(){
      try {
        statusEl.textContent = 'Controllo connessione...';
        const s = await withTimeout((signal)=> tryStatus(signal), 2500);
        if (statusLooksOK(s)){
          setLocked(false);
          statusEl.textContent = 'Dispositivo rilevato.';
          // mostra in result l'output dello status per comodità, se JSON formatta
          if (s.json) resultEl.textContent = JSON.stringify(s.json, null, 2);
          else resultEl.textContent = s.text;
          return true;
        }
        throw new Error('Risposta non valida');
      } catch (err){
        setLocked(true);
        statusEl.textContent = 'Non raggiungibile: ' + (err && err.message ? err.message : 'errore sconosciuto');
        return false;
      }
    }

    // ---- Viewer / Download / Delete ----
    let currentDir = '/';
    function setDir(p){
      p = normalize(p);
      if(!p || p === '') p = '/';
      if(p !== '/' && !p.startsWith('/')) p = '/' + p;
      currentDir = p;
      $('#cwd').textContent = currentDir;
    }

    let folderButtonsTicket = 0;
    async function loadRootDirs(){
      const my = ++folderButtonsTicket;
      statusEl.textContent = 'Carico cartelle (root)...';

      // Raccogli etichette uniche in memoria per evitare duplicati anche in caso di chiamate sovrapposte
      const entries = new Map(); // label -> dirPath
      const addEntry = (label, dirPath) => {
        const key = label.trim();
        if (!entries.has(key)) entries.set(key, dirPath);
      };

      addEntry('root','/');

      // Prova a leggere dal device
      try{
        const txt = await fetchText(`${base()}/fs/list`);
        const data = JSON.parse(txt);
        if(data && data.ok){
          const rows = (data.files || []);
          const names = rows.map(it => (typeof it === 'string') ? it : it.name).filter(Boolean);
          const maybeDirs = rows.map(it => (typeof it === 'string') ? null : !!it.is_dir);
          for (let i=0;i<names.length;i++){
            const name = (names[i] || '').toString();
            const isDir = maybeDirs[i];
            if (name && (isDir === true || (isDir == null && !/\./.test(name)))) {
              addEntry(name, '/' + sanitizeName(name));
            }
          }
        }
      }catch(err){
        // Ignora, useremo fallback
      }

      // Niente fallback: mostra solo cartelle realmente presenti sul device.

      // Se un'altra invocazione ha preso il sopravvento, abort
      if (my !== folderButtonsTicket) return;

      // Costruisci DOM in un fragment e sostituisci atomoicamente
      const frag = document.createDocumentFragment();
      for (const [label, dirPath] of entries){
        const btn = document.createElement('button');
        btn.textContent = label;
        btn.addEventListener('click', async ()=>{
          setDir(dirPath);
          await refreshList();
        });
        frag.appendChild(btn);
      }
      const fb = $('#folderButtons');
      fb.replaceChildren(frag);
      statusEl.textContent = 'Cartelle aggiornate';
    }

    async function refreshList() {
      try {
        statusEl.textContent = 'Carico lista file...';
        fnameEl.innerHTML = "";
        const dirArg = sanitizeName(currentDir);
        const url = dirArg ? `${base()}/fs/list?dir=${encodeURIComponent(dirArg)}`
                           : `${base()}/fs/list`;
        const txt = await fetchText(url);
        const data = JSON.parse(txt);
        if (!data.ok) throw new Error("Lista non valida");

        const rows = (data.files || []);
        const items = rows.map(it => (typeof it === 'string') ? { name: it } : (it || {}));

        let files;
        if (normalize(currentDir) === '/') {
          // Root: mostra solo file che non hanno '/' o '\\' nel nome (no sottocartelle)
          files = items.filter(it => {
            const name = ((it.name || '') + '').toString();
            if (it.is_dir) return false;
            if (name.indexOf('/') !== -1 || name.indexOf('\\') !== -1) return false;
            return allowed('/' + name);
          }).map(it => ({ base: it.name, size: it.size || 0 }));
        } else {
          // Non-root: accetta i file elencati dalla cartella selezionata
          files = items.filter(it => !it.is_dir && allowed(joinPath(currentDir, it.name || '')))
                       .map(it => ({ base: it.name || '', size: it.size || 0 }));
        }

        if (!files || files.length === 0) {
          const opt = document.createElement("option");
          opt.textContent = "(nessun file .txt/.py/.json trovato)";
          opt.value = "";
          fnameEl.appendChild(opt);
        } else {
          for (const e of files) {
            const opt = document.createElement("option");
            opt.value = joinPath(currentDir, e.base);
            opt.textContent = `${e.base} (${e.size || 0} B)`;
            fnameEl.appendChild(opt);
          }
        }
        statusEl.textContent = 'Lista aggiornata';
      } catch (err) {
        statusEl.textContent = 'Errore: ' + err.message;
      }
    }

    async function view() {
      try {
        const path = fnameEl.value;
        if (!path) throw new Error('Seleziona un file');
        if (!allowed(path)) throw new Error('Estensione non ammessa');
        statusEl.textContent = 'Carico ' + path + '...';
        // slash reale nel parametro path (nessuna codifica dello '/')
        const url = `${base()}/fs/download?path=${encodeURI(path)}`;
        const text = await fetchText(url);
        previewEl.textContent = text;
        statusEl.textContent = 'Mostrato ' + path;
      } catch (err) {
        statusEl.textContent = 'Errore: ' + err.message;
      }
    }

    async function download() {
      try {
        const path = fnameEl.value;
        if (!path) throw new Error('Seleziona un file');
        if (!allowed(path)) throw new Error('Estensione non ammessa');

        statusEl.textContent = 'Scarico ' + path + '...';
        // slash reale nel parametro path (nessuna codifica dello '/')
        const url = `${base()}/fs/download?path=${encodeURI(path)}`;
        setURL(url);

        const r = await fetch(url, { cache: 'no-store' });
        if (!r.ok) throw new Error('HTTP ' + r.status);

        const blob = await r.blob();
      
        
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = sanitizeName(path);
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(a.href);

        statusEl.textContent = 'Scaricato ' + path;
      } catch (err) {
        statusEl.textContent = 'Errore: ' + err.message;
      }
    }

    function protect(path) {
      // Nessuna protezione: l'utente accetta il rischio di cancellazioni accidentali
      return false;
    }

    async function delFile() {
      try {
        const path = fnameEl.value;
        if (!path) throw new Error('Seleziona un file');
        if (!allowed(path)) throw new Error('Estensione non ammessa');
        if (protect(path)) throw new Error('File protetto (non eliminabile)');
        if (!confirm(`Eliminare definitivamente ${path}?`)) return;

        statusEl.textContent = 'Elimino ' + path + '...';
        const url = `${base()}/fs/delete`;
        setURL(url);

        const r = await fetch(url, {
          method: 'POST',
          headers: {'Content-Type':'application/json'},
          body: JSON.stringify({ path })
        });
        const txt = await r.text();
        let data = {};
        try { data = JSON.parse(txt); } catch(_) {}
        if (!r.ok || !data.ok) {
          const err = (data && data.err) ? data.err : ('HTTP ' + r.status);
          throw new Error('Delete failed: ' + err);
        }

        statusEl.textContent = 'Eliminato ' + path;
        await refreshList();
        previewEl.textContent = '(contenuto)';
      } catch (err) {
        statusEl.textContent = 'Errore: ' + err.message;
      }
    }

    // ---- Upload / Status / Reboot ----
    async function upload() {
      try {
        const file = fileEl.files[0];
        if (!file) {
          alert("Seleziona un file locale prima!");
          return;
        }
        const url = `${base()}/fs/upload?to=${encodeURI(joinPath(currentDir, file.name))}`;
        statusEl.textContent = "Upload in corso...";
        setURL(url);
        const txt = await fetchText(url, { method: "POST", body: file });
        resultEl.textContent = txt;
        statusEl.textContent = "Upload completato.";
        // rinfresca lista se il file caricato è tra quelli ammessi
        if (allowed("/" + file.name)) {
          await refreshList();
        }
      } catch (err) {
        statusEl.textContent = "Errore: " + err.message;
      }
    }

    async function getStatus() {
      try {
        statusEl.textContent = 'Richiesta status...';
        const s = await withTimeout((signal)=> tryStatus(signal), 2500);
        // mostra sempre il risultato
        if (s.json) resultEl.textContent = JSON.stringify(s.json, null, 2);
        else resultEl.textContent = s.text;
        if (statusLooksOK(s)){
          statusEl.textContent = 'Status ricevuto: OK';
          setLocked(false);
        } else {
          statusEl.textContent = 'Status ricevuto: non valido';
          setLocked(true);
        }
      } catch (err) {
        resultEl.textContent = (err && err.message) ? err.message : String(err);
        statusEl.textContent = 'Errore: ' + (err && err.message ? err.message : 'richiesta fallita');
        setLocked(true);
      }
    }

    async function reboot() {
      try {
        if (!confirm("Confermi reboot del device?")) return;
        statusEl.textContent = "Invio reboot...";
        const txt = await fetchText(`${base()}/reboot`, { method: "POST" });
        resultEl.textContent = txt;
        statusEl.textContent = "Reboot inviato (il device si riavvierà).";
      } catch (err) {
        statusEl.textContent = "Errore: " + err.message;
      }
    }

    // ---- Bind pulsanti ----
    // Selezione cartelle dedicata a sinistra
    // Nessun menu a tendina: i bottoni di livello root gestiscono la selezione

    $('#refreshBtn').addEventListener('click', refreshList);
    $('#viewBtn').addEventListener('click', view);
    $('#downloadBtn').addEventListener('click', download);
    $('#deleteBtn').addEventListener('click', delFile);

    $('#uploadBtn').addEventListener('click', upload);
    $('#statusBtn').addEventListener('click', getStatus);
    $('#rebootBtn').addEventListener('click', reboot);

    // Avvio: imposta root e crea un bottone per ogni cartella (livello 1)
    setDir('/');
    loadRootDirs();
    // All'avvio verifica l'IP di default e blocca/sblocca UI
    checkDevice();

    // Quando si cambia IP, ricarica l'elenco cartelle e forza blocco finché non si fa Status
    $('#ip').addEventListener('change', ()=>{
      loadRootDirs();
      setLocked(true);
      connBanner.classList.remove('hidden');
      statusEl.textContent = 'IP modificato. Premi "Status" per verificare.';
    });
  </script>
</body>
</html>
