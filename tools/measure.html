<html lang="it">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Misure ESP32 — Oscilloscopio + Calibrazione</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Arial, sans-serif; }
    body { margin: 18px; }
    h1 { margin: 0 0 14px; font-size: 22px; }
    h2 { margin: 18px 0 10px; font-size: 20px; }
    .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; margin: 8px 0; }
    input[type="text"], input[type="number"] { padding: 8px; }
    button { padding: 8px 12px; border-radius: 10px; border: 1px solid #ccc; cursor: pointer; }
    .muted { color:#666; font-size:12px }
    canvas { max-width: 100%; height: 60vh; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    #pointsBox { margin:12px 0; padding:8px; border:1px solid #ddd; border-radius:8px; }
    .pill { display:inline-block; padding:2px 8px; border-radius:999px; background:#eee; font-size:12px; }
  </style>
</head>
<body>

  <h1>Misure ESP32</h1>
  <div class="row">
    <label for="sensorSelect"><strong>Sensore:</strong></label>
    <select id="sensorSelect"></select>
    <span class="muted">Scegli il sensore di corrente da usare (es. c1, c2...)</span>
  </div>

  <!-- ===== Sezione 1: Oscilloscopio ===== -->
  <section id="osc">
    <h2>ADC Scope dal browser</h2>
    <div class="row">
      <label for="ip">IP ESP32:</label>
      <input id="ip" type="text" placeholder="es. 192.168.1.10">
      <label for="n">Campioni (n):</label>
      <input id="n" type="number" min="64" max="4096" step="64" value="1024">
      <label for="sr">Sample rate (Hz):</label>
      <input id="sr" type="number" min="100" max="20000" step="100" value="4000">
      <button id="save">Salva</button>
      <button id="start">Start</button>
      <button id="stop" disabled>Stop</button>
    </div>

    <div class="row">
      <span id="status" class="muted">OK (1024 campioni, sr=4000 Hz)</span>
      <span id="last" class="muted">Ultimo aggiornamento: —</span>
    </div>
    
    <!-- Riquadro Ampere live -->
    <div id="ampBox" class="mono" style="margin:8px 0 4px; padding:10px; border:1px solid #ddd; border-radius:10px; background:#fafafa;">
      <strong>Corrente RMS:</strong>
      <span id="ampVal">—</span>
      <span id="ampState" class="pill">—</span>
      <span id="ampMeta" class="muted"></span>
    </div>

    <canvas id="chart"></canvas>
    <div id="errorMsg" style="color:#c00; font-weight:bold; margin-top:8px;"></div>
  </section>

  <hr>

  <!-- ===== Sezione 2: Calibrazione ===== -->
  <section id="calib">
    <h2>Calibrazione CT — Grafico</h2>
    <div class="row">
      <label for="baseUrl">ESP32 base URL:</label>
      <input id="baseUrl" type="text" placeholder="http://192.168.1.10">
      <button id="btnLoad">Ricarica</button>
    </div>

    <!-- Baseline -->
    <div id="baselineBox" class="mono" style="margin:10px 0; padding:8px; border:1px dashed #bbb; border-radius:8px;">
      <strong>Baseline (amp = 0)</strong>
      <span id="baselineVal" class="pill">n/d</span>
      <span id="baselineMeta" class="muted"></span>
      <div class="row" style="margin-top:8px;">
        <button id="btnBaseline">Misura baseline (GET /calibrate?amp=0)</button>
        <button id="btnBaselineDel" title="Resetta TUTTA la calibrazione (baseline + punti)">Elimina baseline (reset)</button>
      </div>
    </div>

    <!-- Box: Aggiungi punto -->
    <div id="addPointBox" class="mono" style="margin:10px 0; padding:8px; border:1px solid #ddd; border-radius:8px;">
      <strong>Aggiungi punto di calibrazione</strong>
      <div class="row" style="margin-top:6px;">
        <label for="ampInput">Ampere (RMS):</label>
        <input id="ampInput" type="number" step="0.1" min="0" placeholder="es. 6.0">
        <label for="ampN">n:</label>
        <input id="ampN" type="number" min="64" max="4096" step="64" value="1600">
        <label for="ampSR">sr (Hz):</label>
        <input id="ampSR" type="number" min="100" max="20000" step="100" value="4000">
        <button id="btnAddPoint">Aggiungi punto (GET /calibrate?amp=...)</button>
      </div>
      <div id="addPointMeta" class="muted"></div>
    </div>

    <div id="meta" class="mono" style="margin-top:8px; color:#333; font-size:14px;"></div>

    <div id="pointsBox" class="mono">
      <div style="display:flex; align-items:center; justify-content:space-between; gap:8px; flex-wrap:wrap;">
        <strong>Punti di calibrazione</strong>
        <button id="btnReload">Ricarica</button>
      </div>
      <div id="pointsList" style="margin-top:8px; font-size:14px;"></div>
    </div>

    <canvas id="chartCal"></canvas>
    <div id="kinfo" class="mono" style="margin-top:8px;"></div>
  </section>

  <!-- Script Oscilloscopio -->
  <script>
  (function(){
    // Funzione url() ora dentro l'IIFE
    function url() {
      console.log('[url] Generazione URL richiesta');
      const ip = ipEl.value.trim();
      const n  = parseInt(nEl.value, 10)  || 1024;
      const sr = parseInt(srEl.value, 10) || 4000;
      const sensor_id = getSensorId();
      if (!ip) throw new Error('IP non valido');
      return `http://${ip}/adc/scope_counts?sensor_id=${encodeURIComponent(sensor_id)}&n=${n}&sr=${sr}&fast=1`;
    }
    const ipEl = document.getElementById('ip');
    const nEl  = document.getElementById('n');
    const srEl = document.getElementById('sr');
    const saveBtn  = document.getElementById('save');
    const startBtn = document.getElementById('start');
    const stopBtn  = document.getElementById('stop');
    const statusEl = document.getElementById('status');
    const lastEl   = document.getElementById('last');
    const ampValEl = document.getElementById('ampVal');
    const ampState = document.getElementById('ampState');
    const ampMeta  = document.getElementById('ampMeta');


    // --- Gestione sensori ---
    const sensorSelect = document.getElementById('sensorSelect');
    let sensors = [];
    function loadSensors() {
      console.log('[loadSensors] Caricamento lista sensori');
      // Static list, in futuro fetch dinamico
      sensors = [
        {id: 'c1', label: 'c1 (pin 34)'},
        {id: 'c2', label: 'c2 (pin 35)'}
      ];
      sensorSelect.innerHTML = '';
      sensors.forEach(s => {
        const opt = document.createElement('option');
        opt.value = s.id; opt.textContent = s.label;
        sensorSelect.appendChild(opt);
      });
      // Default o ultimo usato
      const last = localStorage.getItem('adc.sensor_id') || 'c1';
      sensorSelect.value = last;
    }
    sensorSelect.addEventListener('change', () => {
      localStorage.setItem('adc.sensor_id', sensorSelect.value);
      console.log('[sensorSelect] Sensore selezionato:', sensorSelect.value);
      location.reload(); // Ricarica la pagina per aggiornare la UI
    });

    function getSensorId() {
      return sensorSelect.value || 'c1';
    }

    function loadPrefs() {
      console.log('[loadPrefs] Caricamento preferenze');
      ipEl.value = localStorage.getItem('adc.ip') || '192.168.1.10';
      nEl.value  = localStorage.getItem('adc.n')  || '1024';
      srEl.value = localStorage.getItem('adc.sr') || '4000';
      const calUrl = localStorage.getItem('cal.baseUrl');
      if (!calUrl) document.getElementById('baseUrl').value = 'http://' + ipEl.value.trim();
      loadSensors();
    }
    function savePrefs() {
      console.log('[savePrefs] Salvataggio preferenze');
      const ip = ipEl.value.trim();
      localStorage.setItem('adc.ip', ip);
      localStorage.setItem('adc.n',  nEl.value);
      localStorage.setItem('adc.sr', srEl.value);
      localStorage.setItem('adc.sensor_id', getSensorId());
      const base = 'http://' + ip;
      document.getElementById('baseUrl').value = base;
      localStorage.setItem('cal.baseUrl', base);
      setStatus('Preferenze salvate (sincronizzato URL calibrazione).');
    }

    const ctx = document.getElementById('chart');
    const chart = new Chart(ctx, {
      type: 'line',
      data: { labels: [], datasets: [{ label: 'ADC counts', data: [], borderWidth: 1, pointRadius: 0 }]},
      options: {
        responsive: true, animation: false,
        scales: { x: { title: { display: true, text: 'sample' } }, y: { title: { display: true, text: 'counts' } } },
        plugins: { legend: { display: true } }
      }
    });

    let running = false;
    let fetchInProgress = false;
    const errorMsgEl = document.getElementById('errorMsg');
    function setStatus(msg) { statusEl.textContent = msg; }
    function setLast(ts)    { lastEl.textContent = ts ? ('Ultimo aggiornamento: ' + ts) : ''; }

    function start() {
      if (running) return;
      console.log('[start] Avvio misurazione');
      savePrefs();
      running = true;
      startBtn.disabled = true; stopBtn.disabled = false;
      loopFetch();
    }
    function stop() {
      running = false;
      startBtn.disabled = false; stopBtn.disabled = true;
      setStatus('In pausa.');
      console.log('[stop] Misurazione fermata');
    }

    async function loopFetch() {
      console.log('[loopFetch] Inizio ciclo richieste');
      while (running) {
        await fetchAndPlot();
        // Puoi aggiungere un piccolo delay tra le richieste se vuoi:
        await new Promise(res => setTimeout(res, 200));
      }
      console.log('[loopFetch] Fine ciclo richieste');
    }
    function ampsUrl() {
      const ip = ipEl.value.trim();
      const n  = parseInt(nEl.value, 10)  || 1024;
      const sr = parseInt(srEl.value, 10) || 4000;
      const sensor_id = getSensorId();
      if (!ip) throw new Error('IP non valido');
      return `http://${ip}/amps?sensor_id=${encodeURIComponent(sensor_id)}&n=${n}&sr=${sr}&fast=1`;
    }


    async function fetchAndPlot() {
      if (fetchInProgress) return;
      fetchInProgress = true;
      errorMsgEl.textContent = '';
      console.log('[fetchAndPlot] Invio richieste fetch');
      try {
        const [respCounts, respAmps] = await Promise.all([
          fetch(url(),     { cache: 'no-store' }),
          fetch(ampsUrl(), { cache: 'no-store' }).catch(() => null)
        ]);
        console.log('[fetchAndPlot] Risposta ricevuta', {respCounts, respAmps});
        if (!respCounts || !respCounts.ok) throw new Error('HTTP ' + (respCounts && respCounts.status));
        const j = await respCounts.json();
        if (!j || !Array.isArray(j.counts)) throw new Error('Risposta counts non valida');

        chart.data.labels = j.counts.map((_, i) => i);
        chart.data.datasets[0].data = j.counts;
        console.log('[fetchAndPlot] Aggiorno grafico...');
        const t0 = performance.now();
        chart.update('none');
        const t1 = performance.now();
        console.log(`[fetchAndPlot] Grafico aggiornato in ${(t1-t0).toFixed(2)} ms`, j.counts);

        if (respAmps && respAmps.ok) {
          const a = await respAmps.json();
          console.log('[fetchAndPlot] Dati ampere ricevuti', a);
          if (a.ok) {
            ampState.textContent = 'calibrato';
            ampValEl.textContent = (typeof a.amps_rms === 'number') ? a.amps_rms.toFixed(3) + ' A' : '—';
            const rms = (typeof a.rms_counts === 'number') ? a.rms_counts.toFixed(2) : 'n/d';
            const sr  = a.sr || j.sample_rate_hz || srEl.value;
            ampMeta.textContent = ` (rms=${rms}, sr=${sr})`;
          } else if (a.err === 'busy') {
            ampState.textContent = 'busy'; ampValEl.textContent = '—'; ampMeta.textContent = '';
          } else if (a.err === 'no_model') {
            ampState.textContent = 'non calibrato'; ampValEl.textContent = '—';
            ampMeta.textContent = ' — esegui la calibrazione nella sezione sotto';
          } else {
            ampState.textContent = '—'; ampValEl.textContent = '—'; ampMeta.textContent = '';
          }
        }

        setStatus(`OK (${j.counts.length} campioni, sr=${j.sample_rate_hz || srEl.value} Hz)`);
        setLast(new Date().toLocaleTimeString());
      } catch (err) {
        setStatus('Errore: ' + err.message);
        errorMsgEl.textContent = 'Errore: ' + err.message;
        console.log('[fetchAndPlot] Errore:', err);
      } finally {
        fetchInProgress = false;
        console.log('[fetchAndPlot] fetchInProgress = false');
      }
    }

    // --- LOGICA CORRETTA: richiesta sequenziale ---
    function start() {
      if (running) return;
      savePrefs();
      running = true;
      startBtn.disabled = true; stopBtn.disabled = false;
      loopFetch();
    }
    function stop() {
      running = false;
      startBtn.disabled = false; stopBtn.disabled = true;
      setStatus('In pausa.');
    }

    saveBtn.addEventListener('click', savePrefs);
    startBtn.addEventListener('click', start);
    stopBtn.addEventListener('click', stop);
    loadPrefs();
  })();
  </script>

  <!-- Script Calibrazione (con elenco + delete) -->
  <script>
  (function(){
    const baseUrlEl = document.getElementById("baseUrl");
    const btnLoad = document.getElementById("btnLoad");
    const btnReload = document.getElementById("btnReload");
    const metaEl = document.getElementById("meta");
    const kinfoEl = document.getElementById("kinfo");
    const baselineValEl = document.getElementById("baselineVal");
    const baselineMetaEl = document.getElementById("baselineMeta");
    const btnBaseline = document.getElementById("btnBaseline");
    const btnBaselineDel = document.getElementById("btnBaselineDel");
    const pointsListEl = document.getElementById("pointsList");

    baseUrlEl.value = localStorage.getItem('cal.baseUrl') || baseUrlEl.value || "http://192.168.1.10";
    // --- sensore anche in calibrazione ---
    const sensorIdCal = () => (localStorage.getItem('adc.sensor_id') || 'c1');
    baseUrlEl.addEventListener('change', () => {
      const v = baseUrlEl.value.replace(/\/+$/,'');
      localStorage.setItem('cal.baseUrl', v);
    });

    const ctx = document.getElementById("chartCal").getContext("2d");
    const chart = new Chart(ctx, {
      type: "scatter",
      data: { datasets: [] },
      options: {
        animation: false, responsive: true, parsing: false,
        scales: {
          x: { title: { display: true, text: "RMS (counts ADC)" } },
          y: { title: { display: true, text: "Corrente RMS (A)" } }
        },
        plugins: { legend: { position: "top" }, tooltip: { mode: "nearest", intersect: false } }
      }
    });

    function dot(ax, ay) { let s=0; for (let i=0;i<ax.length;i++) s+=ax[i]*ay[i]; return s; }
    function r2Score(y, yhat) {
      const n = y.length; if (!n) return NaN;
      const ym = y.reduce((a,b)=>a+b,0)/n;
      let ssRes = 0, ssTot = 0;
      for (let i=0;i<n;i++) { ssRes += (y[i]-yhat[i])**2; ssTot += (y[i]-ym)**2; }
      return ssTot === 0 ? 1 : (1 - ssRes/ssTot);
    }

    async function renderPoints(base, cal) {
      // baseline box
      const bm = cal.baseline_mean;
      const n0 = cal.n0, sr0 = cal.sr0;
      baselineValEl.textContent = (bm == null) ? "n/d" : String(bm);
      baselineMetaEl.textContent = (n0 || sr0) ? `  (n0: ${n0 ?? "n/d"}, sr0: ${sr0 ?? "n/d"})` : "";

      const pts = (cal.points || []).map((p,i)=>({ i, rms: Number(p.rms_counts), amps: Number(p.amps) }));
      // lista
      if (!pts.length) {
        pointsListEl.innerHTML = "<em>Nessun punto salvato.</em>";
      } else {
        const ul = document.createElement("ul");
        ul.style.listStyle = "none"; ul.style.padding = "0"; ul.style.margin = "0";
        pts.forEach(p => {
          const li = document.createElement("li");
          li.style.display = "flex";
          li.style.alignItems = "center";
          li.style.justifyContent = "space-between";
          li.style.gap = "8px";
          li.style.borderTop = "1px dashed #ccc";
          li.style.padding = "6px 0";

          const left = document.createElement("span");
          left.textContent = `#${p.i}  rms_counts=${p.rms}  |  amps=${p.amps}`;

          const btn = document.createElement("button");
          btn.textContent = "Elimina";
          btn.title = "Rimuovi questo punto";
          btn.onclick = async () => {
            if (!confirm(`Confermi rimozione del punto #${p.i}?`)) return;
            try {
              const sensor_id = sensorIdCal();
              const r = await fetch(base + "/calibrate/delete", {
                method: "POST",
                mode: "cors",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ index: p.i, sensor_id })
              });
              const j = await r.json();
              if (!j.ok) throw new Error(j.err || "operazione fallita");
              await load(); // ricarica tutto
            } catch (e) { alert("Errore delete: " + e); }
          };

          li.appendChild(left);
          li.appendChild(btn);
          ul.appendChild(li);
        });
        pointsListEl.innerHTML = ""; pointsListEl.appendChild(ul);
      }
    }

    async function load() {
      const base = baseUrlEl.value.replace(/\/+$/,"");
      localStorage.setItem('cal.baseUrl', base);
      const sensor_id = sensorIdCal();
      const url = base + "/calibrate?sensor_id=" + encodeURIComponent(sensor_id) + "&fast=1";
      metaEl.textContent = "Carico: " + url + " ...";
      try {
        const r = await fetch(url, { cache: "no-store" });
        const j = await r.json();
        const cal = j.cal || j;

        const pts = (cal.points || []).map(p => ({x: Number(p.rms_counts), y: Number(p.amps)}));
        const xs = pts.map(p=>p.x), ys = pts.map(p=>p.y);

        const kSaved = Number(cal.k_A_per_count || 0);
        let kFit = 0;
        if (xs.length) {
          const sxy = dot(xs, ys), sxx = dot(xs, xs);
          kFit = sxx > 0 ? (sxy / sxx) : 0;
        }

        const maxX = xs.length ? Math.max(...xs) : 1;
        const lineX = []; const lineYSaved = []; const lineYFit = [];
        const xMax = maxX * 1.15 || 1;
        for (let x=0; x<=xMax; x += xMax/100) {
          lineX.push(x); lineYSaved.push(kSaved * x); lineYFit.push(kFit * x);
        }

        chart.data.datasets = [
          { label: "Punti", data: pts, showLine: false, pointRadius: 4 }
        ];
        if (kSaved > 0) {
          chart.data.datasets.push({
            label: `Linea (k salvato = ${kSaved.toFixed(8)} A/count)`,
            data: lineX.map((x,i)=>({x, y: lineYSaved[i]})),
            showLine: true, fill: false
          });
        }
        chart.data.datasets.push({
          label: `Linea (k fit = ${kFit.toFixed(8)} A/count)`,
          data: lineX.map((x,i)=>({x, y: lineYFit[i]})),
          showLine: true, borderDash: [6,4], fill: false
        });
        chart.update();

        metaEl.textContent = `Punti: ${pts.length}  •  baseline_mean: ${cal.baseline_mean ?? "n/d"}  •  n0: ${cal.n0 ?? "n/d"}  •  sr0: ${cal.sr0 ?? "n/d"}`;
        await renderPoints(base, cal);

        const yhatSaved = xs.map(x => kSaved * x);
        const yhatFit   = xs.map(x => kFit * x);
        const r2Saved = (kSaved>0 && xs.length) ? r2Score(ys, yhatSaved) : NaN;
        const r2Fit   = (kFit>0   && xs.length) ? r2Score(ys, yhatFit)   : NaN;
        kinfoEl.textContent = `R²(k salvato) = ${isNaN(r2Saved)? "n/d" : r2Saved.toFixed(5)}   |   R²(k fit) = ${isNaN(r2Fit)? "n/d" : r2Fit.toFixed(5)}`;

      } catch(e) {
        metaEl.textContent = "Errore fetch: " + e;
        chart.data.datasets = []; chart.update();
        pointsListEl.innerHTML = "";
        kinfoEl.textContent = "";
      }
    }

    // baseline: misura (GET /calibrate?amp=0)
    btnBaseline.addEventListener("click", async () => {
      const base = baseUrlEl.value.replace(/\/+$/," ");
      const sensor_id = sensorIdCal();
      try {
        const r = await fetch(base + "/calibrate?amp=0&sensor_id=" + encodeURIComponent(sensor_id) + "&fast=1", { method: "GET", mode: "cors" });
        const j = await r.json();
        if (!j.ok) throw new Error(j.err || "operazione fallita");
        await load();
      } catch (e) { alert("Errore baseline: " + e); }
    });

    // baseline: reset totale
    btnBaselineDel.addEventListener("click", async () => {
      const base = baseUrlEl.value.replace(/\/+$/,"");
      if (!confirm("Questa operazione resetta TUTTA la calibrazione (baseline + punti). Procedere?")) return;
      try {
        const sensor_id = sensorIdCal();
        const r = await fetch(base + "/calibrate/reset?sensor_id=" + encodeURIComponent(sensor_id) + "&fast=1", { method: "POST" });
        const j = await r.json();
        if (!j.ok) throw new Error(j.err || "operazione fallita");
        await load();
      } catch (e) { alert("Errore reset: " + e); }
    });

    document.getElementById("btnAddPoint").addEventListener("click", async () => {
      const base = baseUrlEl.value.replace(/\/+$/," ");
      const sensor_id = sensorIdCal();
      const A   = parseFloat(document.getElementById("ampInput").value);
      const n   = parseInt(document.getElementById("ampN").value || "1600", 10);
      const sr  = parseInt(document.getElementById("ampSR").value || "4000", 10);
      const addMeta = document.getElementById("addPointMeta");
      if (!isFinite(A) || A <= 0) { alert("Inserisci un valore di Ampere RMS > 0"); return; }
      addMeta.textContent = "Misuro e salvo il punto...";
      try {
        const url = `${base}/calibrate?amp=${encodeURIComponent(A)}&n=${n}&sr=${sr}&sensor_id=${encodeURIComponent(sensor_id)}&fast=1`;
        const r = await fetch(url, { method: "GET", mode: "cors", cache: "no-store" });
        const j = await r.json();
        if (!j.ok) {
          if (j.err === "busy") throw new Error("Dispositivo occupato, riprova tra poco");
          throw new Error(j.err || "operazione fallita");
        }
        const clip = j.clipping ? ` ⚠️ clipping (min=${j.min}, max=${j.max})` : "";
        addMeta.textContent = `✅ Punto aggiunto: A=${A}  |  rms=${j.added?.rms_counts ?? "n/d"}  |  k=${j.k_A_per_count}  |  baseline=${j.baseline_mean}${clip}`;
        document.getElementById("ampInput").value = "";
        await load();
      } catch (e) {
        addMeta.textContent = "❌ Errore add point: " + e;
        console.log(e);
      }
    });

    btnLoad.addEventListener("click", load);
    btnReload.addEventListener("click", load);
    // autopopola
    const maybe = localStorage.getItem('cal.baseUrl');
    if (maybe) baseUrlEl.value = maybe;
    load();
  })();
  </script>
</body>
</html>
