<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Calibrazione CT — Grafico</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 16px; }
    h1 { margin: 0 0 8px 0; }
    .row { display: flex; flex-wrap: wrap; gap: 12px; align-items: center; margin-bottom: 10px; }
    input[type=text] { padding: 6px 8px; min-width: 320px; }
    button { padding: 6px 10px; cursor: pointer; }
    #meta { margin-top: 8px; color: #333; font-size: 14px; }
    canvas { max-width: 100%; height: 60vh; }
    .kbox { margin-top: 8px; font-size: 14px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <h1>Calibrazione CT — Grafico</h1>
  <div class="row">
    <label for="baseUrl">ESP32 base URL:</label>
    <input id="baseUrl" type="text" placeholder="http://192.168.1.24" />
    <button id="btnLoad">Ricarica</button>
  </div>
  <div id="meta" class="mono"></div>
    <div id="pointsBox" class="mono" style="margin:12px 0; padding:8px; border:1px solid #ddd; border-radius:8px;">
    <div style="display:flex; align-items:center; justify-content:space-between; gap:8px; flex-wrap:wrap;">
      <strong>Punti di calibrazione</strong>
      <button id="btnReload" title="Ricarica dati">Ricarica</button>
    </div>
    <div id="pointsList" style="margin-top:8px; font-size:14px;"></div>
  </div>
  <canvas id="chart"></canvas>
  <div id="kinfo" class="kbox mono"></div>

<script>
(function() {
  // UI
  const baseUrlEl = document.getElementById("baseUrl");
  const btnLoad = document.getElementById("btnLoad");
  const metaEl = document.getElementById("meta");
  const kinfoEl = document.getElementById("kinfo");

  // Leggi ?host=... se presente
  const urlParams = new URLSearchParams(window.location.search);
  const host = urlParams.get("host");
  if (host) baseUrlEl.value = host.startsWith("http") ? host : ("http://" + host);
  if (!baseUrlEl.value) baseUrlEl.value = "http://192.168.1.24";

    // --- Render elenco punti + delete ---
  async function renderPoints(base, cal) {
    const listEl = document.getElementById("pointsList");
    const pts = (cal.points || []).map((p, i) => ({
      i,
      rms: Number(p.rms_counts),
      amps: Number(p.amps)
    }));

    if (!pts.length) {
      listEl.innerHTML = "<em>Nessun punto salvato.</em>";
      return;
    }

    const ul = document.createElement("ul");
    ul.style.listStyle = "none";
    ul.style.padding = "0";
    ul.style.margin = "0";

    pts.forEach(p => {
      const li = document.createElement("li");
      li.style.display = "flex";
      li.style.alignItems = "center";
      li.style.justifyContent = "space-between";
      li.style.gap = "8px";
      li.style.borderTop = "1px dashed #ccc";
      li.style.padding = "6px 0";

      const left = document.createElement("span");
      left.textContent = `#${p.i}  rms_counts=${p.rms}  |  amps=${p.amps}`;

      const btn = document.createElement("button");
      btn.textContent = "Elimina";
      btn.title = "Rimuovi questo punto";
      btn.onclick = async () => {
        if (!confirm(`Confermi rimozione del punto #${p.i}?`)) return;
        try {
          const r = await fetch(base + "/calibrate/delete", {
            method: "POST",
            mode: "cors",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ index: p.i })
          });
          const j = await r.json();
          if (!j.ok) throw new Error(j.err || "operazione fallita");
          await load(); // ricarica grafico e lista
        } catch (e) {
          alert("Errore delete: " + e);
        }
      };

      li.appendChild(left);
      li.appendChild(btn);
      ul.appendChild(li);
    });

    listEl.innerHTML = "";
    listEl.appendChild(ul);
  }
  // Chart.js
  const ctx = document.getElementById("chart").getContext("2d");
  const chart = new Chart(ctx, {
    type: "scatter",
    data: { datasets: [] },
    options: {
      animation: false,
      responsive: true,
      parsing: false,
      scales: {
        x: { title: { display: true, text: "RMS (counts ADC)" } },
        y: { title: { display: true, text: "Corrente RMS (A)" } }
      },
      plugins: {
        legend: { position: "top" },
        tooltip: { mode: "nearest", intersect: false }
      }
    }
  });

  function r2Score(y, yhat) {
    const n = y.length;
    if (!n) return NaN;
    const ym = y.reduce((a,b)=>a+b,0)/n;
    let ssRes = 0, ssTot = 0;
    for (let i=0;i<n;i++) {
      ssRes += (y[i]-yhat[i])*(y[i]-yhat[i]);
      ssTot += (y[i]-ym)*(y[i]-ym);
    }
    return ssTot === 0 ? 1 : (1 - ssRes/ssTot);
  }

  function dot(ax, ay) {
    let s = 0; for (let i=0;i<ax.length;i++) s += ax[i]*ay[i]; return s;
  }

  async function load() {
    const base = baseUrlEl.value.replace(/\/+$/,"");
    const url = base + "/calibrate";
    metaEl.textContent = "Carico: " + url + " ...";
    try {
      const r = await fetch(url, { cache: "no-store" });
      const j = await r.json();
      const cal = j.cal || j; // supporta sia {"cal":{...}} che {...}
      const pts = (cal.points || []).map(p => ({x: Number(p.rms_counts), y: Number(p.amps)}));
      const xs = pts.map(p=>p.x);
      const ys = pts.map(p=>p.y);

      // pendenza salvata (se presente)
      const kSaved = Number(cal.k_A_per_count || 0);
      // best-fit vincolato all'origine
      let kFit = 0;
      if (xs.length && ys.length) {
        const sxy = dot(xs, ys);
        const sxx = dot(xs, xs);
        kFit = sxx > 0 ? (sxy / sxx) : 0;
      }

      // linee
      const maxX = xs.length ? Math.max(...xs) : 1;
      const lineX = [];
      const lineYSaved = [];
      const lineYFit = [];
      const xMax = maxX * 1.15 || 1;
      for (let x=0; x<=xMax; x += xMax/100) {
        lineX.push(x);
        lineYSaved.push(kSaved * x);
        lineYFit.push(kFit * x);
      }

      // R^2
      const yhatSaved = xs.map(x => kSaved * x);
      const yhatFit = xs.map(x => kFit * x);
      const r2Saved = isFinite(kSaved) && kSaved > 0 ? r2Score(ys, yhatSaved) : NaN;
      const r2Fit = isFinite(kFit) && kFit > 0 ? r2Score(ys, yhatFit) : NaN;

      // aggiorna chart
      chart.data.datasets = [
        { label: "Punti di calibrazione", data: pts, showLine: false, pointRadius: 4 }
      ];
      if (kSaved > 0) {
        chart.data.datasets.push({
          label: `Linea (k salvato = ${kSaved.toFixed(8)} A/count)`,
          data: lineX.map((x,i)=>({x, y: lineYSaved[i]})),
          showLine: true,
          fill: false
        });
      }
      chart.data.datasets.push({
        label: `Linea (k fit = ${kFit.toFixed(8)} A/count)`,
        data: lineX.map((x,i)=>({x, y: lineYFit[i]})),
        showLine: true,
        borderDash: [6,4],
        fill: false
      });
      chart.update();

      metaEl.textContent = `Punti: ${pts.length}  •  baseline_mean: ${cal.baseline_mean ?? "n/d"}  •  n0: ${cal.n0 ?? "n/d"}  •  sr0: ${cal.sr0 ?? "n/d"}`;
      await renderPoints(base, cal);
      kinfoEl.textContent = `R²(k salvato) = ${isNaN(r2Saved)? "n/d" : r2Saved.toFixed(5)}   |   R²(k fit) = ${isNaN(r2Fit)? "n/d" : r2Fit.toFixed(5)}`;
    } catch (e) {
      metaEl.textContent = "Errore nel fetch: " + e;
      chart.data.datasets = [];
      chart.update();
    }
  }

  btnLoad.addEventListener("click", load);
  document.getElementById("btnReload").addEventListener("click", load);
  load(); // auto on start
})();
</script>
</body>
</html>
